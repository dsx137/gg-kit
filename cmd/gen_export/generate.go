package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/types"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

// gen 为一个包生成 ggkit 包装文件。
//
// 策略：
//   - 将类型导出为类型别名
//   - 将常量导出为常量别名
//   - 通过 getter+setter 函数导出变量
//   - 通过转发包装器导出函数
//
// 额外策略（关键特性）：
//  1. 类型渲染：如果签名提到了我们重新导出为本地类型别名的被包装包中的命名类型，则不带 "alias." 打印它。
//  2. 泛型：包装器类型参数只包括在参数/结果中引用的那些；
//     只有当无法从参数进行类型推断时才发出调用点类型参数。
func gen(p *packages.Package, pkgName string, alias string) []byte {
	ign := ignores(p)
	scope := p.Types.Scope()

	var typesN, funcsN, varsN, constN []string
	for _, name := range scope.Names() {
		if !ast.IsExported(name) || ign[name] {
			continue
		}
		switch scope.Lookup(name).(type) {
		case *types.TypeName:
			typesN = append(typesN, name)
		case *types.Func:
			funcsN = append(funcsN, name)
		case *types.Var:
			varsN = append(varsN, name)
		case *types.Const:
			constN = append(constN, name)
		}
	}
	sort.Strings(typesN)
	sort.Strings(constN)
	sort.Strings(varsN)
	sort.Strings(funcsN)

	// 我们通过 `type X = alias.X` 重新导出的类型
	localTypes := make(map[string]bool, len(typesN))
	for _, n := range typesN {
		localTypes[n] = true
	}
	tw := newTypeWriter(p.PkgPath, localTypes)

	var b bytes.Buffer
	fmt.Fprintf(&b, "// Code generated by cmd/gen; DO NOT EDIT.\n\n")
	fmt.Fprintf(&b, "package %s\n\n", pkgName)
	fmt.Fprintf(&b, "import %s %q\n\n", alias, p.PkgPath)

	for _, n := range typesN {
		fmt.Fprintf(&b, "%s\n", typeAliasLine(p, alias, n))
	}
	if len(typesN) > 0 {
		fmt.Fprintf(&b, "\n")
	}

	for _, n := range constN {
		fmt.Fprintf(&b, "const %s = %s.%s\n", n, alias, n)
	}
	if len(constN) > 0 {
		fmt.Fprintf(&b, "\n")
	}

	for _, n := range varsN {
		v := scope.Lookup(n).(*types.Var)
		t := tw.Type(v.Type())
		fmt.Fprintf(&b, "func %s() %s { return %s.%s }\n", n, t, alias, n)
		fmt.Fprintf(&b, "func Set%s(v %s) { %s.%s = v }\n\n", n, t, alias, n)
	}

	for _, n := range funcsN {
		fn := scope.Lookup(n).(*types.Func)
		sig := fn.Type().(*types.Signature)
		decl, call := wrapFunc(n, sig, alias, tw)
		fmt.Fprintf(&b, "%s {\n\t%s\n}\n\n", decl, call)
	}

	return b.Bytes()
}

func typeAliasLine(p *packages.Package, alias, name string) string {
	obj := p.Types.Scope().Lookup(name).(*types.TypeName)

	// 只有命名类型才能拥有类型参数
	named, _ := obj.Type().(*types.Named)
	if named == nil || named.TypeParams() == nil || named.TypeParams().Len() == 0 {
		return fmt.Sprintf("type %s = %s.%s", name, alias, name)
	}

	// 生成：type Queue[T any] = structure.Queue[T]
	tps := named.TypeParams()
	var decl []string
	var use []string
	for i := 0; i < tps.Len(); i++ {
		tp := tps.At(i)
		decl = append(decl, fmt.Sprintf("%s %s", tp.Obj().Name(), types.TypeString(tp.Constraint(), qname)))
		use = append(use, tp.Obj().Name())
	}
	return fmt.Sprintf("type %s[%s] = %s.%s[%s]", name, strings.Join(decl, ", "), alias, name, strings.Join(use, ", "))
}

func wrapFunc(name string, sig *types.Signature, alias string, tw *typeWriter) (decl string, stmt string) {
	gp := planGenerics(sig)

	pDecl, args := params(sig, tw)
	rDecl := results(sig, tw)

	// 调用：仅当无法从参数推断类型时才包含显式类型参数。
	call := fmt.Sprintf("%s.%s%s(%s)", alias, name, gp.callArgs(), args)

	if rDecl != "" {
		decl = fmt.Sprintf("func %s%s(%s) %s", name, gp.wrapperDecl(), pDecl, rDecl)
		stmt = "return " + call
	} else {
		decl = fmt.Sprintf("func %s%s(%s)", name, gp.wrapperDecl(), pDecl)
		stmt = call
	}
	return
}

func params(sig *types.Signature, tw *typeWriter) (decl, args string) {
	ps := sig.Params()
	var d, a []string
	for i := 0; i < ps.Len(); i++ {
		v := ps.At(i)
		n := v.Name()
		if n == "" || n == "_" {
			n = fmt.Sprintf("_p%d", i)
		}

		// 可变参数处理
		if sig.Variadic() && i == ps.Len()-1 {
			sl := v.Type().(*types.Slice)
			elem := tw.Type(sl.Elem())
			d = append(d, fmt.Sprintf("%s ...%s", n, elem))
			a = append(a, n+"...")
			continue
		}

		t := tw.Type(v.Type())
		d = append(d, fmt.Sprintf("%s %s", n, t))
		a = append(a, n)
	}
	return strings.Join(d, ", "), strings.Join(a, ", ")
}

func results(sig *types.Signature, tw *typeWriter) string {
	rs := sig.Results()
	if rs.Len() == 0 {
		return ""
	}
	var parts []string
	for i := 0; i < rs.Len(); i++ {
		v := rs.At(i)
		t := tw.Type(v.Type())
		if v.Name() != "" {
			parts = append(parts, v.Name()+" "+t)
		} else {
			parts = append(parts, t)
		}
	}
	return "(" + strings.Join(parts, ", ") + ")"
}

func qname(p *types.Package) string { return p.Name() }
